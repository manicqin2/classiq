"""Repository layer for database operations."""

import uuid

from sqlalchemy import select, func
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from db.models import Task, TaskStatus, StatusHistory


class TaskRepository:
    """Repository for Task database operations following the repository pattern."""

    def __init__(self, session: AsyncSession):
        """
        Initialize the TaskRepository with a database session.

        Args:
            session: AsyncSession instance for database operations
        """
        self.session = session

    async def create_task(self, circuit: str, shots: int = 1024) -> Task:
        """
        Create a new task with the given circuit and shots parameter.

        Args:
            circuit: The quantum circuit string to be compiled
            shots: Number of circuit executions (default: 1024)

        Returns:
            Task: The newly created Task object with generated UUID

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Create new Task instance
            # UUID and submitted_at are auto-generated by the model
            # status defaults to PENDING
            task = Task(
                circuit=circuit,
                shots=shots,
                current_status=TaskStatus.PENDING
            )

            # Add to session and flush to get the generated task_id
            self.session.add(task)
            await self.session.flush()
            await self.session.refresh(task)

            # Create initial status history entry
            await self.create_status_history_entry(
                task_id=task.task_id,
                status=TaskStatus.PENDING,
                notes="Task created"
            )

            return task

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(f"Error creating task: {str(e)}") from e

    async def get_task(self, task_id: uuid.UUID) -> Task | None:
        """
        Retrieve a task by its ID.

        Args:
            task_id: UUID of the task to retrieve

        Returns:
            Task | None: The Task object if found, None otherwise

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Query task by task_id
            stmt = select(Task).where(Task.task_id == task_id)
            result = await self.session.execute(stmt)
            task = result.scalar_one_or_none()

            return task

        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Error retrieving task {task_id}: {str(e)}") from e

    async def get_task_with_history(self, task_id: uuid.UUID) -> Task | None:
        """
        Retrieve a task by its ID with all status history eagerly loaded.

        This method uses eager loading to fetch the task and all its status history
        entries in a single query, ordered by transition time ascending.

        Args:
            task_id: UUID of the task to retrieve

        Returns:
            Task | None: The Task object with populated status_history relationship
                       if found, None otherwise

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Query task by task_id with eager loading of status history
            # Status history is ordered by transitioned_at ascending
            stmt = (
                select(Task)
                .where(Task.task_id == task_id)
                .options(
                    selectinload(Task.status_history)
                )
            )
            result = await self.session.execute(stmt)
            task = result.scalar_one_or_none()

            return task

        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Error retrieving task {task_id} with history: {str(e)}") from e

    async def update_task_status(
        self,
        task_id: uuid.UUID,
        from_status: TaskStatus,
        to_status: TaskStatus,
        result: dict | None = None,
        error_message: str | None = None,
        notes: str | None = None
    ) -> bool:
        """
        Update task status with optimistic locking to prevent race conditions.

        This method uses row-level locking and status verification to ensure that
        only one worker can transition a task from a specific status. If another
        worker has already changed the status, this method returns False.

        Args:
            task_id: UUID of the task to update
            from_status: Expected current status (for optimistic locking)
            to_status: New status to set
            result: Optional result dict (for COMPLETED status)
            error_message: Optional error message (for FAILED status)
            notes: Optional notes for status history entry

        Returns:
            bool: True if update succeeded, False if status already changed

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Query task with row-level locking (SELECT FOR UPDATE)
            stmt = (
                select(Task)
                .where(Task.task_id == task_id)
                .with_for_update()
            )
            result_set = await self.session.execute(stmt)
            task = result_set.scalar_one_or_none()

            # Check if task exists
            if task is None:
                return False

            # Check if current status matches expected from_status (optimistic locking)
            if task.current_status != from_status:
                # Status already changed by another worker
                return False

            # Update status
            task.current_status = to_status

            # Set completed_at for terminal states
            if to_status in (TaskStatus.COMPLETED, TaskStatus.FAILED):
                task.completed_at = func.now()

            # Set result if provided (typically for COMPLETED status)
            if result is not None:
                task.result = result

            # Set error_message if provided (typically for FAILED status)
            if error_message is not None:
                task.error_message = error_message

            # Commit the transaction
            await self.session.commit()

            # Create status history entry after successful update
            # Use provided notes or generate default message
            history_notes = notes if notes is not None else f"Status changed from {from_status.value} to {to_status.value}"
            await self.create_status_history_entry(
                task_id=task_id,
                status=to_status,
                notes=history_notes
            )

            return True

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(
                f"Error updating task {task_id} status from {from_status} to {to_status}: {str(e)}"
            ) from e

    async def create_status_history_entry(
        self,
        task_id: uuid.UUID,
        status: TaskStatus,
        notes: str | None = None
    ) -> None:
        """
        Create a new StatusHistory record for a task.

        Args:
            task_id: UUID of the task
            status: The status to record in history
            notes: Optional notes about the status transition

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Create new StatusHistory instance
            # transitioned_at is auto-generated by server_default
            status_history = StatusHistory(
                task_id=task_id,
                status=status,
                notes=notes
            )

            # Add to session and commit
            self.session.add(status_history)
            await self.session.commit()

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(
                f"Error creating status history for task {task_id}: {str(e)}"
            ) from e
