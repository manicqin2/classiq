"""Repository layer for database operations."""

import uuid

from sqlalchemy import func, select, update
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from db.models import StatusHistory, Task, TaskStatus


class TaskRepository:
    """Repository for Task database operations following the repository pattern."""

    def __init__(self, session: AsyncSession):
        """
        Initialize the TaskRepository with a database session.

        Args:
            session: AsyncSession instance for database operations
        """
        self.session = session

    async def create_task(self, circuit: str, shots: int = 1024) -> Task:
        """
        Create a new task with the given circuit and shots parameter.

        Args:
            circuit: The quantum circuit string to be compiled
            shots: Number of circuit executions (default: 1024)

        Returns:
            Task: The newly created Task object with generated UUID

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Create new Task instance
            # UUID and submitted_at are auto-generated by the model
            # status defaults to PENDING
            task = Task(circuit=circuit, shots=shots, current_status=TaskStatus.PENDING)

            # Add to session and flush to get the generated task_id
            self.session.add(task)
            await self.session.flush()
            await self.session.refresh(task)

            # Create initial status history entry
            await self.create_status_history_entry(
                task_id=task.task_id, status=TaskStatus.PENDING, notes="Task created"
            )

            return task

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(f"Error creating task: {str(e)}") from e

    async def get_task(self, task_id: uuid.UUID) -> Task | None:
        """
        Retrieve a task by its ID.

        Args:
            task_id: UUID of the task to retrieve

        Returns:
            Task | None: The Task object if found, None otherwise

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Query task by task_id
            stmt = select(Task).where(Task.task_id == task_id)
            result = await self.session.execute(stmt)
            task = result.scalar_one_or_none()

            return task

        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Error retrieving task {task_id}: {str(e)}") from e

    async def get_task_with_history(self, task_id: uuid.UUID) -> Task | None:
        """
        Retrieve a task by its ID with all status history eagerly loaded.

        This method uses eager loading to fetch the task and all its status history
        entries in a single query, ordered by transition time ascending.

        Args:
            task_id: UUID of the task to retrieve

        Returns:
            Task | None: The Task object with populated status_history relationship
                       if found, None otherwise

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Query task by task_id with eager loading of status history
            # Status history is ordered by transitioned_at ascending
            stmt = (
                select(Task)
                .where(Task.task_id == task_id)
                .options(selectinload(Task.status_history))
            )
            result = await self.session.execute(stmt)
            task = result.scalar_one_or_none()

            return task

        except SQLAlchemyError as e:
            raise SQLAlchemyError(f"Error retrieving task {task_id} with history: {str(e)}") from e

    async def update_task_status(
        self,
        task_id: uuid.UUID,
        from_status: TaskStatus,
        to_status: TaskStatus,
        result: dict | None = None,
        error_message: str | None = None,
        notes: str | None = None,
    ) -> bool:
        """
        Update task status with optimistic locking to prevent race conditions.

        This method uses an atomic UPDATE with status verification in the WHERE clause
        to ensure that only one worker can transition a task from a specific status.
        If another worker has already changed the status, the UPDATE affects 0 rows
        and this method returns False.

        This approach is more efficient than SELECT FOR UPDATE because:
        - Single database round-trip instead of two (SELECT + UPDATE)
        - No pessimistic lock held, allowing higher concurrency
        - Workers fail fast if status already changed

        Args:
            task_id: UUID of the task to update
            from_status: Expected current status (for optimistic locking)
            to_status: New status to set
            result: Optional result dict (for COMPLETED status)
            error_message: Optional error message (for FAILED status)
            notes: Optional notes for status history entry

        Returns:
            bool: True if update succeeded, False if status already changed or task not found

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Build UPDATE statement with status check in WHERE clause (atomic operation)
            stmt = (
                update(Task)
                .where(Task.task_id == task_id)
                .where(Task.current_status == from_status)  # Optimistic locking check
                .values(current_status=to_status)
            )

            # Set completed_at for terminal states
            if to_status in (TaskStatus.COMPLETED, TaskStatus.FAILED):
                stmt = stmt.values(completed_at=func.now())

            # Set result if provided (typically for COMPLETED status)
            if result is not None:
                stmt = stmt.values(result=result)

            # Set error_message if provided (typically for FAILED status)
            if error_message is not None:
                stmt = stmt.values(error_message=error_message)

            # Execute atomic update
            result_set = await self.session.execute(stmt)
            await self.session.commit()

            # Check if any row was updated
            rows_affected = result_set.rowcount
            if rows_affected == 0:
                # Either task doesn't exist OR status already changed by another worker
                return False

            # Create status history entry after successful update
            # Use provided notes or generate default message
            history_notes = (
                notes
                if notes is not None
                else f"Status changed from {from_status.value} to {to_status.value}"
            )
            await self.create_status_history_entry(
                task_id=task_id, status=to_status, notes=history_notes
            )

            return True

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(
                f"Error updating task {task_id} status from {from_status} to {to_status}: {str(e)}"
            ) from e

    async def create_status_history_entry(
        self, task_id: uuid.UUID, status: TaskStatus, notes: str | None = None
    ) -> None:
        """
        Create a new StatusHistory record for a task.

        Args:
            task_id: UUID of the task
            status: The status to record in history
            notes: Optional notes about the status transition

        Raises:
            SQLAlchemyError: If there's an error during database operations
        """
        try:
            # Create new StatusHistory instance
            # transitioned_at is auto-generated by server_default
            status_history = StatusHistory(task_id=task_id, status=status, notes=notes)

            # Add to session and commit
            self.session.add(status_history)
            await self.session.commit()

        except SQLAlchemyError as e:
            await self.session.rollback()
            raise SQLAlchemyError(
                f"Error creating status history for task {task_id}: {str(e)}"
            ) from e
